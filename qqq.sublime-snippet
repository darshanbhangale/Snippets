<snippet>
	<content><![CDATA[
//2019B4A80800G
#include<bits/stdc++.h>
using namespace std;
typedef long long int ll;
typedef vector<ll>  vi;
typedef set<ll> si;
const int imax=INT_MAX;
const int imin=INT_MIN;
const long long int llmax=LLONG_MAX;
const long long int llmin=LLONG_MIN;
#define pb push_back
#define F_OR(i, a, b, s) for (ll i=(a); (s)>0?i<(b):i>(b); i+=(s))
#define F_OR1(e) F_OR(i, 0, e, 1)
#define F_OR2(i, e) F_OR(i, 0, e, 1)
#define F_OR3(i, b, e) F_OR(i, b, e, 1)
#define F_OR4(i, b, e, s) F_OR(i, b, e, s)
#define GET5(a, b, c, d, e, ...) e
#define F_ORC(...) GET5(__VA_ARGS__, F_OR4, F_OR3, F_OR2, F_OR1)
#define rep(...) F_ORC(__VA_ARGS__)(__VA_ARGS__)
#define nl cout<<"\n";
#define cnl cerr<<"\n";
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define sall(x) sort((x).begin(),(x).end());
#define rall(x) sort((x).rbegin(),(x).rend()); 
#define meme(x, y) memset(x, y, sizeof(x))
#define each(a,x) for (auto& a: x)
#define ff first
#define ss second
#define yes cout<<"YES\n";
#define no cout<<"NO\n";
#define tcT template<typename T
#define tcTU template<typename T, typename U
#define maxa(a,n) *max_element(a,a+n)
#define mina(a,n) *min_element(a,a+n)
#define maxv(v) *max_element(v.begin(), v.end())
#define minv(v) *min_element(v.begin(), v.end())
template<typename... TT>
void read(TT&... args){
    ((cin>>args),...);
}
template<typename... TT>
void write(TT&&... args){
    ((cout<<args<<" "),...);
}
#define deb(...) dbg(#__VA_ARGS__, __VA_ARGS__);
template <typename Arg1> void dbg(const char* name, Arg1&& arg1){cerr <<" "<< name << " = " << arg1 << endl;}
template <typename Arg1, typename... Args>void dbg(const char* names, Arg1&& arg1, Args&&... args)
{
    const char* comma = strchr(names + 1, ',');
    cerr<<" ";
    cerr.write(names, comma - names) << " = " << arg1;
    dbg(comma, args...);
}
namespace binary_search_kar_jaldi{
    tcTU> T first_True(T lo,T hi, U F){
        hi++;assert(lo <=hi);
        while(lo<hi){
            T mid= lo+(hi-lo)/2;
            F(mid) ? hi=mid :lo =mid+1;
        }
        return lo;
    }
    tcTU> T last_True(T lo,T hi, U F){
        lo--;assert(lo<=hi);
        while(lo<hi){
            T mid=lo+(hi-lo+1)/2;
            F(mid) ? lo=mid : hi=mid-1;
        }
        return lo;
    }
}
tcT> T div_rounded_up(T a, T b) { return a/b+((a^b)>0&&a%b); }
tcT> T div_rounded_down(T a, T b) { return a/b-((a^b)<0&&a%b); }
tcT> bool getBIT(T mask,int k){
    return ((mask>>k)&1);
}
tcT> void setBIT(T& mask,int k){
    mask=(mask|(1<<(k-1)));
    return;
}
tcTU> ostream& operator<<(ostream &cout, pair<T, U> const &p) { return cout <<"("<<p.ff<<", "<<p.ss<<")"; }
tcT> ostream& operator<<(ostream &cout, vector<T> const &v) {
    cout<<"[";
     for(int i = 0; i < v.size(); i++) {if (i) cout << ", "; cout << v[i];} return cout << "]";
}
tcTU> ostream& operator<<(ostream &cout,map<T,U> const &m){
    for(auto x:m){
        cout<<x.ff<<"-> "<<x.ss<<"\n";
    }
    return cout<<"";
}
tcT> istream& operator>>(istream& cin, vector<T> &v) {
    rep(i,0,v.size()-1){cin>>v[i];}
    return cin >> v[v.size()-1];
}
tcTU> istream& operator>>(istream& cin, pair<T, U> &p) {
    cin >> p.first;
    return cin >> p.second;
}
tcT> bool operator+=(vector<T> &v,T elem){
    v.pb(elem);
    return true;
}
tcT> pair<T,T> operator++(vector<vector<T>> &adj){
    T p,q;cin>>p>>q;
    p--;q--;
    adj[p].pb(q);
   adj[q].pb(p);
   return {p,q};
}
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
tcT> using my_set=tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;
tcT> using my_multi_set=tree<T,null_type,less_equal<T>,rb_tree_tag,tree_order_statistics_node_update>;
template<ll MOD>
class Modular{
public:
    ll value;
    static const ll MOD_Value=MOD;
    Modular():value(0){}
    explicit operator ll() const { return value; }
    void normalize() {this->value%=MOD;if(this->value < 0 ){(this->value)+=MOD;}}
    Modular(ll newVal) : value(ll(newVal % MOD_Value)) { if (value < 0) value += MOD; }
    friend bool operator == (const Modular& a, const Modular& b) { return a.value == b.value; }
    friend bool operator != (const Modular& a, const Modular& b) { return a.value != b.value; }
    friend bool operator < (const Modular& a, const Modular& b) { return a.value < b.value; }
    friend bool operator > (const Modular& a, const Modular& b) { return a.value > b.value; }
    friend bool operator <= (const Modular& a, const Modular& b) { return a.value <= b.value; }
    friend bool operator >= (const Modular& a, const Modular& b) { return a.value >= b.value; }
    friend Modular power(Modular a, ll p) {
        Modular ans = 1; assert(p >= 0);
        for (; p; p /= 2, a *= a) if (p&1){ans *= a;}; return ans;}
    friend Modular inv(const Modular& a) { assert(a.value != 0);return power(a,MOD-2);}
    Modular& operator += (const Modular& o) {
        value += o.value;
        if (value >= MOD) value -= MOD;
        return *this;
    }
    Modular& operator -= (const Modular& o) {
        value -= o.value;
        if (value < 0) value += MOD;
        return *this;
    }
    Modular& operator *= (const Modular& o) {
        value = (ll)(ll(value) * ll(o.value) % MOD);
        return *this;
    }
    Modular& operator ++ () {
        value ++;
        if (value == MOD) value = 0;
        return *this;
    }
    Modular& operator -- () {
        if (value == 0) value = MOD;
        value --;
        return *this;
    }
    Modular& operator/=(const Modular& o) { return (*this) *= inv(o); }
    friend Modular operator ++ (Modular& a, int) { Modular r = a; ++a; return r; }
    friend Modular operator -- (Modular& a, int) { Modular r = a; --a; return r; }
    friend Modular operator+(Modular a, const Modular& b) { return a += b; }
    friend Modular operator-(Modular a, const Modular& b) { return a -= b; }
    friend Modular operator*(Modular a, const Modular& b) { return a *= b; }
    friend Modular operator/(Modular a, const Modular& b) { return a /= b; }
};
template<ll md> ostream& operator<<(ostream &cout,Modular<md> const &m){
    cout<<m.value;
    return cout<<"";
}
template<ll md> istream& operator>>(istream &cin,Modular<md> &m){
cin>>m.value;
m.normalize();
    return cin;
}
constexpr ll modTakenAsInput=1e9+7;
using Mint =Modular<modTakenAsInput>;

int main()
{
ios_base::sync_with_stdio(0);
cin.tie(0);cout.tie(0);

$0


























return 0;
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	 <tabTrigger>qqq</tabTrigger> 
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
